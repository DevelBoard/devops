#!/usr/bin/env python
#
# repoman - OPKG Repository Management Tool
# Copyright (C) 2015  Develer S.r.l.
#
# Author: Lorenzo Villani <lvillani@develer.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


# Motivation and Purpose
# ======================
#
# This script acts as a buffer between IPK packages produced by Yocto and the directory holding
# the final repository available to end-users.
#
# A script like this one is needed because, sometimes, Yocto rebuilds all dependent packages once
# a dependency changes, even when no significant change happen with the dependency's code
# itself. The script detects packages with the same name but different check-sums between the
# source and destination directory and allows the operator to decide how to handle conflicts
# (which in most cases boils down to ignoring the conflict).
#
#
#
# Glossary
# ========
#
# * Source directory: a directory full of .ipk files as produced by Yocto. Generally
#   `tmp/deploy/ipk` relative to the build directory.
# * Destination directory: a directory holding the final repository that will be served
#   to end-users.
# * Conflict: a package whose name and architecture is the same between the source and
#   destination directories, but have differing check-sums.
#   A conflicting package can be:
#   - Accepted: it will be copied from source to destination (this is frown upon,
#     you should bump the release of a particular package instead).
#   - Ignored: the .ipk from the destination directory will be copied back to the
#     source so that it doesn't generate a new conflict until Yocto decides to build
#     it again.
#
#
#
# How to Use
# ==========
#
# In its basic form this program takes two arguments:
#
# 1. The source directory;
# 2. The destination directory;
#
# In case there are conflicts, they are shown on the command line and the script exits with a
# non-zero status code. Said list can be also written to disk by passing the "-w" switch followed
# by the file name to write to.
#
# The conflict file contains one entry per line in this format:
# <architecture>/<package name>.ipk
#
# Given a list of conflicts you can choose to either accept or ignore them. Refer to the glossary
# (above) to learn the meaning of "accepting" or "ignoring" a conflict.


from __future__ import print_function

import argparse
import gzip
import md5
import os
import os.path
import resource
import shutil
import subprocess
import sys

IGNORED_ARCHITECTURES = ["x86_64-nativesdk"]


def main():
    args = parse_args()
    distro_codename = get_distro_codename(args.source)
    distro_version = get_distro_version(args.source)
    dest = get_dest_root(args.destination, distro_codename, distro_version)
    opkg = get_opkg_path(args.source)

    # Prep
    sanity_check(args.source, opkg)
    prep_destination(dest)

    # Load packages to accept (i.e.: copy from source to destination) in case of conflicts.
    accept = [] if not args.accept else lines_from_file(args.accept)

    # Ignoring a package conflict works by copying the destination package to the source so that
    # they become identical.
    process_ignored(args.source, dest, [] if not args.ignore else lines_from_file(args.ignore))

    # Process the source directory and handle conflicts.
    conflicts = process_source(args.source, dest, accept)
    if conflicts:
        if args.write_conflicts:
            open(args.write_conflicts, "w").writelines(c + os.linesep for c in conflicts)
        else:
            display_conflicts(conflicts)

        sys.exit(1)

    # Rebuild Packages + Packages.gz + Packages.stamp
    build_indexes(dest, opkg)

    # Sync to S3
    if args.sync:
        sync(args.destination)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-a", "--accept", type=str)
    parser.add_argument("-i", "--ignore", type=str)
    parser.add_argument("-s", "--sync", action="store_true")
    parser.add_argument("-w", "--write-conflicts", type=str)

    parser.add_argument("source")
    parser.add_argument("destination")

    return parser.parse_args()


def get_distro_codename(source):
    return get_repo_metadata(os.path.join(source, "DISTRO_CODENAME"))


def get_distro_version(source):
    return get_repo_metadata(os.path.join(source, "DISTRO_VERSION"))


def get_repo_metadata(p):
    if not os.path.isfile(p):
        die(p + ": no such file.\nThis file is generated by the packagegroup-develboard-repo target.")

    d = lines_from_file(p)
    if not d or not d[0]:
        die("Unable to read repository metadata")

    return d[0]


def get_dest_root(root, codename, version):
    return os.path.join(root, codename, version)


def get_opkg_path(source):
    return os.path.abspath(os.path.join(source, "..", "..", "sysroots", "x86_64-linux", "usr", "bin", "opkg-make-index"))


def sanity_check(source, opkg):
    if not os.path.isfile(os.path.join(source, "Packages")):
        die("Source directory does not appear to be valid")

    if not os.path.isfile(opkg) and not os.access(opkg, os.X_OK):
        die("Cannot find opkg-make-index executable:" + os.linesep + opkg)


def die(*args):
    print(*args)
    sys.exit(1)


def prep_destination(dest):
    if not os.path.isdir(dest):
        os.makedirs(dest)


def lines_from_file(path):
    with open(path, "r") as f:
        return [l.strip() for l in f if l.strip()]


def process_ignored(source, dest, ignore):
    for p in ignore:
        shutil.copyfile(os.path.join(dest, p), os.path.join(source, p))


def process_source(root, dest, accept):
    dirs = onlydirs(root)
    to_process = [d for d in dirs if not os.path.basename(d) in IGNORED_ARCHITECTURES]
    conflicts = []

    for subtree in to_process:
        conflicts.extend(process_architecture_subtree(root, subtree, dest, accept))

    return conflicts


def onlydirs(path):
    entries = os.listdir(path)
    paths = [os.path.join(path, p) for p in entries]

    return [d for d in paths if os.path.isdir(d)]


def process_architecture_subtree(root, subtree, dest, accept):
    conflicts = []

    for dirpath, dirnames, filenames in os.walk(subtree):
        for filename in [f for f in filenames if f.endswith(".ipk")]:
            abspath = os.path.join(dirpath, filename)
            relpath = os.path.relpath(abspath, root)
            destdir = os.path.join(dest, os.path.dirname(relpath))
            destpath = os.path.join(dest, relpath)

            if not os.path.isdir(destdir):
                os.makedirs(destdir)

            if not os.path.isfile(destpath):
                shutil.copyfile(abspath, destpath)
            elif not are_identical(abspath, destpath):
                handle_conflict(abspath, destpath, accept, conflicts)

    return conflicts


def are_identical(source_path, dest_path):
    return md5_of(source_path) == md5_of(dest_path)


def md5_of(path):
    m = md5.new()

    with open(path, "rb") as f:
        block = read_block(f)

        while block:
            m.update(block)

            block = read_block(f)

    return m.digest()


def read_block(f):
    return f.read(resource.getpagesize())


def handle_conflict(source_path, dest_path, accepted, conflicts):
    coord = os.sep.join(source_path.split(os.sep)[-2:])  # <architecture>/<package name>

    if coord in accepted:
        shutil.copyfile(source_path, dest_path)
    else:
        conflicts.append(coord)


def display_conflicts(conflicts):
    print("The following packages have the same name but differ between the source")
    print("and the destination:")

    for conflict in conflicts:
        print(conflict)


def build_indexes(dest, opkg):
    for arch in onlydirs(dest):
        packages = os.path.join(arch, "Packages")
        packages_gz = os.path.join(arch, "Packages.gz")

        subprocess.check_call([opkg, "-p", packages, arch])
        gzip_file(packages, packages_gz)


def gzip_file(src, dst):
    with open(src, "rb") as fin, gzip.open(dst, "wb") as fout:
        shutil.copyfileobj(fin, fout)


def sync(dest):
    subprocess.check_call(["aws", "s3", "sync", "--delete", "--region", "eu-west-1",
                           dest, "s3://pkg.develboard.com/"])


if __name__ == "__main__":
    main()
